Set:
set<int> s;

хранит элементы без повторений
чтобы их получить нужно получить итератор.
for (auto it = s.begin(); it != s.end(); it++) {
	cout << (*it) << endl;
} // выводит элементы по порядку

s.begin(); - итератор первого элемента
s.end(); - итератор последнего элемента

auto it = s.begin();
it++; - следующий по порядку элемент

s.insert(2); - вставить элемент
s.find(2); - поиск элемента(возвращает итератор)
s.erase(s.find(2)); - удаляет элемент
s.size(); - размер
s.lower_bound(n); - находит первый элемент который > n
s.upper_bound(n); - находит первый элемент который >= n
(все операции работают за O(log s.size()))

?? s.rbegin(), s.rend()

-------------------------------------------------------------------------------------------

Multiset:
multiset<int> ms;
set, но хранит элементы с повторениями

/// .count()

-------------------------------------------------------------------------------------------

Unordered Set
unordered_set<int> uos;
set, но работает не по порядку

-------------------------------------------------------------------------------------------

Pair
pair<int, int> p;
(vector<pair<int, int>>)

-------------------------------------------------------------------------------------------

Map
(map<key, value> m;)
map<int, int> m;
Как словарь в питоне
m[1] = 100
m[29] = 34; ...

auto it = m.find(29)
cout << (*it).first << " " << (*it).second << endl; - 29 34

for(auto it = m.begin(); it != m.end(); it++) {
	cout << (*it).first << " " << (*it).second << endl;
}

/// . lower_bound, upper_bound, count ... ()

